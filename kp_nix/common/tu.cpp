#include "tu.h"
#include "acksenum.h"
#include "pamessage.h"

// статические члены класса
DWORD Tu::Counter = 0;                                  // уникальный счетчик в пределах сессии
std::queue <std::shared_ptr<Tu>> Tu::listToDo;          // очередь ТУ на исполнение
std::mutex Tu::todo_lock;                               // блокировка доступа к очереди TODO

// Данный файл включает определения для класса Tu и код потока ThreadTU
// Класс ТУ создается при приеме команды в статической функции Tu::PushTu
// В этот момент создается умный разделяемый указатель, который записывается в очередь
// Tu:listToDo - статический член класса Tu
// Время жизни класса - до мосента удаления из очереди
// Учитывая организацию сплошного списка ТУ во фрейме ТУ, помещать ТУ в очередь исполненных большого резона нет
// кроме как отображения времени исполнения ТУ. Можно добавить столбец, а можно не добавлять,
// а при необходимости анализировать протокол (большого резона видеть на экране время исполнения
// последней ТУ не видно, хотя это вопрос обсуждаемый
// Если все-таки доваить еще одну очередь, время жизни будет определяться наличием ТУ хотя в одной из очередей

Tu::Tu(WORD tu, SUBSYSTYPE sys/*=SYS_KP*/, ARM_TYPE arm/* = ARM_DNC*/, CANAL_TYPE ch/* = CANAL_1*/)
{
    id = ++Counter;                                     // уникальный счетчик в пределах сессии
    this->tu = tu;                                      // код ТУ

    sysType   = sys;                                    // тип ЭЦ, на который направляется ТУ
    armType   = arm;                                    // тип АРМ, выдавший ТУ
    canalType = ch;                                     // тип канала (используются для идентификации канала ТУ ЭЦ-МПК)

    time (&tRcv);
    tBeg = tEnd = 0;                                    // нулевые времена косвенно определяют статус ТУ (начали исполнять, закончили)

    // извлечь атрибуты ТУ из кода ТУ (заглушка)
    mod  = 1;                                           // модуль
    out  = id;                                          // выход (сейчас для имитации- порядковый номер ТУ)
    delay= 4000;                                        // задержка
}


// запись ТУ в основную (общую) очередь
// надо иметь версию функции без блокировки, чтобы при приеме нескольких ТУ положить их внутри одной блокировки
// это важно, если существуют спаренные ТУ, которые должны выбираться в одном цикле, иначе можно их разделить
void Tu::PushTu(WORD _tu, SUBSYSTYPE sys, ARM_TYPE arm, CANAL_TYPE ch)// ТУ - в очередь
{
    std::shared_ptr<Tu> tu(new Tu(_tu, sys, arm, ch), [](Tu *p) { Log (L"delete TU !!!"); delete p; } );
                                    //-------------------------------------------------  - так можно отследить факт удаления указателя,
                                    //                                                     можно убрать люмбда-функцию, включая запятую
    {
    std::lock_guard<std::mutex> locker(Tu::todo_lock);  // лучше освободить очередь до вызова SendMessage
    listToDo.push(tu);
    }
    SendMessage(new PaMessage(tuAckRcv, tu));
}

int Tu::todoSize()
{
    std::lock_guard <std::mutex> locker(todo_lock);
    return listToDo.size();
}


