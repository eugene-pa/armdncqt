#ifndef ROUTE_H
#define ROUTE_H

#include "../common/logger.h"
#include "sprbase.h"
#include "station.h"
#include "station.h"
#include "svtf.h"
#include "strl.h"
#include "rc.h"
//#include "properties.h"

class Route : public SprBase
{
    friend class DStDataFromMonitor;                        // для формирования и извлечения информации в потоке ТС
    friend class DDataFromMonitor;

public:

    enum ROTE_TYPE						// Типы маршрутов (поле Type) - СМ.ТАБЛИЦУ TypeOfRoute БД
    {
        ROUT_I_SINGLE	= 0,			// П	прием
        ROUT_O_SINGLE	= 1,			// О	отправление
        ROUT_I_COMPLEX	= 2,			// СП	составной прием
        ROUT_O_COMPLEX	= 3,			// СО	составное отправление
        ROUT_IO_THROUGH	= 4,			// С	составной сквозной (прием,отправление)
        ROUT_MANEVR    	= 5,			// М	маневровый
        ROUT_I_PRD		= 6,			// ПРДП	передача (при этом прием на осн.путь)
        ROUT_O_PRD		= 7,			// ПРДО	передача (при этом отпрвл.с осн.пути)
        ROUT_PRD		= 8,			// ПРД	передача с осн.на осн.путь
        ROUT_M_COMLEX	= 9,			// маневровый составной
    };

    enum ROUTE_STS
    {
        RQSET		=1,					// переводим стрелки "ж"
        RQOPEN		=2,					// стрелки переведены, открываем сигнал "ж"
        WAIT_CLOSE	=3,					// все ОК, контролируем изменение состояния "з"
        WAIT_RZMK	=4,					// ждем размыкания ИЛИ АВТОДЕЙСТВИЯ
        WAIT_OTHER	=5,					// ожидание установки другого маршрута (освобождения наборной группы)
//		DEPOSIT		=6,					// ожидание выполнения условий для сборки (накопление)
    };


    // открытые статические функции
    static Route * GetById(int id);                         // получить справочник по уникальному ключу(номеру) маршрута
    static Route * GetByNo(int no, Station* st);            // получить справочник по уникальному ключу(номеру) маршрута
    static void DoRoutes(Station* st);                      // обработка всех маршрутов
    static bool ReadBd (QString& dbpath, Logger& logger);   // чтение БД

    Route();
    ~Route();

private:
    static QHash <int, Route *> routes;                     // маршруты, индексированные по индексу ТС

    // Константные данные ==========================================================
    int     id;            		                            // номеp (код) маршрута, совпадающий с индексом
    bool	dir;				                            // напpавление маpшpута		0-чет, 1-нечет

//    WORD	IndRc;				                            // 1-ый индекс маpш.(РЦ)
//    WORD	IndStrl;			                            // 2-ой инд. маpш.(cтpелки)
//    WORD	IndCross;			                            // 3-й индекс - враждебные
    QString	path;                                           // Имя пути в маpшpуте
    QString	pathFrom;                                       // Имя пути в маpшpуте ОТКУДА для передачи
//  int     park;				                            // номеp парка,если есть, иначе 0
    ROTE_TYPE type;				                            // тип маршрута (см.выше)
                                                            // 0 - прием									ROUT_I_SINGLE
                                                            // 1 - отправление								ROUT_O_SINGLE
                                                            // 2 - составной прием							ROUT_I_COMPLEX
                                                            // 3 - составное отправление					ROUT_O_COMPLEX
                                                            // 4 - составной сквозной (прием,отправление)	ROUT_IO_THROUGH
                                                            // 5 - маневровый								ROUT_MANEVR
                                                            // 6 - передача (при этом прием на осн.путь)	ROUT_I_PRD
                                                            // 7 - передача (при этом отпрвл.с осн.пути)	WORD ROUT_O_PRD
                                                            // 8 - передача с осн.на осн.путь				WORD ROUT_PRD
                                                            // "П","О","СП","СО","С","М"

    bool	bDouble;			                            // составной, задаваемый отдельной командой ТУ
    int     noSvtf;				                            // номеp светофоpа из БД, ограждающего начало маршрута (0 для составных)
    Svtf *  pSvtfBeg;                                       // указатель на класс, описывающий ограничивающий начало маршрута светофор; если не описан - NULL
    Svtf *  pSvtfEnd;                                       // указатель на класс, описывающий ограничивающий конец маршрута светофор; если не описан - NULL
    Rc   *  pNextRc;                                        // указатель на класс, описывающий следующую РЦ за маршрутом

    bool	fBegEnd;                                        // Признак маршрутного набора - задание НАЧАЛО КОНЕЦ
    bool	bSetStrlBefore;		                            // Признак необходимости перевести стрелки перед дачей команды

    bool	bAutoPeregonPending;                            // Идет разворот перегона при установке маршрута
    QDateTime tPeregonOk;			                        // Засечка времени, когда перегон развернулся; после этого надо выдержать N сек. перед установкой маршрута

    CString TuSet;                                          // ЗАДАНИЕ МАРШРУТА (Список ТУ через пробел; если он пустой - переводим стрелки и открываем сигнал)
    QList <Tu*> tuSetList;                                  // список ТУ установки маршрута

    CString	tuCancelName;			                        // ОТМЕНА МАРШРУТА (Список ТУ через пробел; если он пустой - закрываем сигнал)
    QList <Tu*> tuCancelList;                               // список ТУ установки маршрута

    CString cancelModeTs;		                            // ТС для контроля зависания режима набора маршрута
    CString cancelModeTu;		                            // ТУ для отмены режима набора маршрута в случае зависания

    QString	zmkName;			                            // код имени обобщенного сигнала замыкания
    Ts *    zmkTs;                                          // справочник обобщенного сигнала замыкания

    QList <Route *> listRoutes;                             // список составных маршрутов (пустой для элементарных)
    QList <Rc*    >	listRc;		                            // список РЦ  в маpшpуте
    QList <Strl  *>	listStrl;	                            // список стpелок в маpшpуте
    QList <Route *> listCrossRoutes;                        // список враждебных маршрутов

    int     idType;				                            // код вида маршрута (ключ для RouteType)
    CString	TuText;				                            // имя ТУ (для ручного ввода)
    CString	HelpText;			                            // Расшифровка (генерим автоматически по типу)
    CString Text;				                            // Описание (из БД, пишется "вручную", более осмысленное, чем HelpText)

    bool	bWrongWay;			                            // 2015.02.03. Неправильный путь (в имени встечается текст "неправ")
                                                            // =0 при посекционном замыкании
//	WORD	NoPrompt;			                            // код текст. подсказки

};

#endif // ROUTE_H
