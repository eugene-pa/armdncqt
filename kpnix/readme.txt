kpnix - тестовый проект, иллюстрирующий некоторые подходы к созданию проекта ПО КП на базе unix-подобных систем

Основные подходы:
- максимальное использование стандартной библиотеки
- в разумных пределах максимально возможная кроссплатформенность
- там где это необходимо и оправдано, использование библиотек QT
- цель: опробование базовых механизмов, наметка некоего каркаса приложения, позволяющего далее портировать существующий 
  код реализации отдельных задач на новую платформу. Целевое приложение буде GUI-шное, но пока хочется максимально 
  отделить базовую функциональную часть, это проще сделать в консольном, хотя в консоли есть свои нюансы, я еще не разобрался.

В принципе, бОльшая часть микропроекта сделана с использованием STL. 
Что касается стиля явного написания пространства имен std::  и вместо использования оператора using namespace std - 
пишут разное, и у меня пока по разному) QT используется помимо обрамления проекта в основном при реализации работы с COM-портом, 
что является на данном этапе оправданным. Другого кроссплатформенного решения работы c COM-портом я не нашел. Более того, в исходных кодах QT
кроссплатформенность реально достигается использованием разных файлов для разных платформ, настолько разнятся 
реализации этих вещей. При необходимости файл работы с COM-портом может быть заменен для конкретной платформы.

Что представляет интерес в проекте:
- используются потоки STL std::thread
- используются мьютексы STL std::mutex
- каждый рабочий поток крутится в цикле ожидая захвата мьютекса exit_lock в течении определенного времени,
  (время определяется требуемой периодичностью выполнения основной задачи потока. Мьютекс exit_lock изначально 
  блокирован основным потоком, при завершении работы блокировка освобождается и все потоки могут завершить работу
- для временной блокировки вместе с мьютексом широко используется "безопасный" класс lock_guard<mutex>, обеспечивающий автоматическую 
  разблокировку в деструкторе, что с одной стороны избавляет от необходимости ручной разблокировки, с другой - гарантирует 
  разблокировку при выбрасывании исключений в защищаемом куске кода
- очереди ТУ реализованы на базе контейнера queue(см.поток ThreadTU, где иллюстрируется выборка и исполнение команд)
- поток ThreadPolling иллюстрирует реализацию протокола информационного обмена линейного уровня в части работы с COM-портом
  (реализация протокола пунктирная для иллюстрации, обмен работает)
- для работы с COM-портом используется оригинальный класс RsAsinc, описанный ниже.
- остальные потоки - однотипны, используются для тестирования блокировок, реальной работы там нет 


// Интерфейсный класс для работы с COM-портом в стиле, принятом в ПО ДЦ ЮГ
//   а именно: с использованием перегруженной функции GetCh(int ms) - получить символ в течении ограниченного времени
//   Класс необходим по той причине, что класс QSerialPort, входящий в состав QT, не позволяет выбирать
//   данные посимвольно в аналогичной манере: при уведомлении о наличии данных нужно считать ВСЕ имеющиеся на этот момент 
//   доступные символы. Если считать 1 символ, уведомлений больше не будет до получения новых данных 
// Интерфейсный класс выполняет следующие функции:
//   - открытие порта с заданными настройками в следующем формате (пример):  "COM1,9600,N,8,1"
//   - буферирование принимаемых данных в очереди FIFO и выдачу данных по требованию посимвольно (GetCh())
//   - передачу данных
// Важно:
// 1.Попытка реализовать прием данных в отдельном потоке std::thread без использования сигналов/слотов QT,
//   но путем использования waitForReadyRead, приводила к задержкам в обработке двнных:
//   данные не терялись, а зависали где-то в недрах QSerialPort и выдавались при приеме следующих данных
//   Возможно, можно было попробовать использовать QThread взамен std::thread (см.класс RxProxy)
// 2.В консольных приложениях есть проблемы использования QSerialPort: передачу данных надо завершать
//   вызовом waitForBytesWritten, иначе данные просто не передаются.
//   Причем документация утверждает, что этот вызов может приводить к зависанию GUI приложений
//   Поэтому рекомендуется раскомментировать определение CONSOLAPP в файле rsasinc.h для консольных приложений
// 3. Для синхронизации используются средства STL:
//      - std::mutex mtxBuf                 - блокировка доступа к очереди
//      - std::mutex mtxWater               - мьютекс для организации ожидания поступления данных
//      - std::condition_variable water     - условие ожидание приема данных, позволяющее организовать ожидание
//                                            ввода с пробуждением при приеме
// 4. В качестве контейнера используется стандартный контейнер std::deque<unsigned char> (хотя можно было использовать queue)
// 5. При использовании класса в консольном приложении необходимо выполнить ряд доп.условий:
//    - класс должен быть объявлен в основном потоке (так как в этом потоке будет цикл обработки сообщений)
//    - обязательно должен быть выполнен вызов QCoreApplication.exec(), иначе не работают сигналы и слоты
// 6. Для чтения используются 3 функции:
//      int  GetCh();             получить символ с ожиданием не более timeWaiting миллисекунд, иначе возврат -1
//      unsigned char GetChEx();  получить символ с ожиданием не более timeWaiting миллисекунд, иначе исключение RsException
//      int  GetCh(int ms);       получить символ с ожиданием не более ms миллисекунд, иначе возврат -1
